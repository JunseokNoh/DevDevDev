# [17070] 파이프 옮기기 1 - Java

## :pushpin: **Algorithm**

DP (동적 계획법), 그래프 이론

## :round_pushpin: **Logic**

```java
for (int x = 0; x < N; x++) {
  for (int y = 2; y < N; y++) {
      if (map[x][y] == 1) {
          continue;
      }

      // 다음 좌표에 파이프가 가로로 놓일 경우는 이전 좌표에서 파이프가 가로였거나, 대각선인 경우
      cases[x][y][0] = cases[x][y - 1][0] + cases[x][y - 1][1];

      if (x == 0) {
          continue;
      }

      // 다음 좌표에 파이프가 세로로 놓일 경우는 이전 좌표에서 파이프가 세로였거나, 대각선인 경우
      cases[x][y][2] = cases[x - 1][y][1] + cases[x - 1][y][2];

      // 파이프의 대각선 이동을 위해 벽 체크, x, y에 대해서는 위에서 걸러짐
      if (map[x - 1][y] == 1 || map[x][y - 1] == 1) {
          continue;
      }

      // 다음 좌표에 파이프가 대각선으로 놓일 경우는 이전 좌표에서 파이프가 가로였거나, 세로였거나, 대각선인 경우
      cases[x][y][1] = cases[x - 1][y - 1][0] + cases[x - 1][y - 1][1] + cases[x - 1][y - 1][2];
  }
}
return cases[N - 1][N - 1][0] + cases[N - 1][N - 1][1] + cases[N - 1][N - 1][2];
```

- 이전 좌표에서 파이프의 모양에 따라, 다음 좌표에서의 파이프 모양이 결정되고, 그에 따라 경우의 수가 결정된다.
- 가로, 대각선 -> 가로
- 세로, 대각선 -> 세로
- 가로, 세로, 대각선 -> 대각선

## :black_nib: **Review**
- BFS 방식과 DFS 방식으로 경우의 수를 늘려 구현했으나 89%에서 시간초과를 피할 수 없었다.
- DP를 이용해서 이전의 정보를 활용하는 방식이어야 해결이 가능했고, 이전 풀이를 참고했다.